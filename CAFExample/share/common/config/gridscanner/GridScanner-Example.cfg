# -*- mode: conf -*-
# input file, colon separates sample folder name

# General Options 
# ==========================================

runGridScanner.inputFile:   sampleFolders/analyzed/samples-analyzed-GridScanner-Example.root:samples
runGridScanner.outputFile:  results/GridScanner-Example/gridscanner-example.root

# plot directory
runGridScanner.plotDirectory:   results/GridScanner-Example

# name of the booked multidimensional histogram
# as specified in your multidimensional histogram definition file
runGridScanner.nDimHistName:  GridScan_Example_Hist

# set region (cut) where optimization is done
runGridScanner.simple.regions: CutMll

# PrepareGrid Options 
# ==========================================

# to avoid numerical issues
# with very small background expectations
# we put a lower cutoff for the exp. background
runGridScanner.cutoff:    0.001
# points which will have a lower background value
# will be discarded and not taken into account
# default is zero, e.g. no cutoff
# alternatively or additionally, we can put a cutoff
# on the relative exp. background uncertainty
# that way, we can discard points with low statistics
# or with issues due to negative event weights
# even without placing an explicit cut 
# on the background expectation
runGridScanner.relBkgErrCutoff: 1.0
# now, points where the relative exp. bkg. uncertainty
# exceeds 100% will be discarded

# ScanGrid Options 
# ==========================================

# what channels to scan? (done in separate scans)
runGridScanner.scanChannels:  [em+me]

# define what to consider as signal and background for grid scan
runGridScanner.simple.signal: /sig/$(LEPCH)/mh125/vbf
runGridScanner.simple.background: /bkg/$(LEPCH)

# the following text file specifies the variables
# and their ranges to scan. for further
# information see file
runGridScanner.boundaryList: common/config/gridscanner/scan-boundaries.txt 

# choosing the figure of merit(s).
# multiple figure of merits can be specified.
# curent available options:
# poisson, s/sqrt(b), s/sqrt(s+b), s/b, s*s/(b*b)
# runGridScanner.evaluator: poisson
runGridScanner.figureOfMerits: poisson, s/sqrt(b)
# In case a figure of merit is used where parameter can be inputted:
# runGridScanner.figureOfMeritParameters: 0.4
# choose index of figure of merit w.r.t. which results
# should be sorted (default is 0)
# runGridScanner.indexFOMForSorting: 0

# CURRENTLY NOT IMPLEMENTED
# the following options can be used to repeatedly execute
# an external command while running the scan
# this can be useful for extremely long running jobs
# you can e.g. renew kerberos tokens every 24h on lxplus
# the heartbeat command can be an arbitrary shell command
# runGridScanner.heartBeatCommand: kinit -R
# the heartbeat interval is in milliseconds
# the below number corresponds to 23h 50min
# runGridScanner.heartBeatInterval: 85800000

# do you want the scanner to print status updates?
runGridScanner.verbose: true
# do you want tons of output from HistFactory?
runGridScanner.evaluator.verbose: true
# do you want tons of output from the TQSampleDataReader
# collecting your Histograms?
runGridScanner.reader.verbose: true

# How many points to you want to have printed on the console?
runGridScanner.numberOfPointsPrinted: 10

# SIMPLE significance evaluator options 
# ==========================================

# this will set the axis on which the final figure of merit is calculated,
# i.e where the integral is computed 
runGridScanner.simple.axisToEvaluate: MT

# CL significance evaluator options 
# ==========================================

runGridScanner.cl.variableOfInterest: MT







# MakePlots Options 
# ==========================================

# want to make plots?
# specify argument '--plotResults' or '--plotInputs' when executing
# runGridScanner.py script

# draw vertical lines at given X-coordinates in significance profile
# plots can be used to denote current baseline cut values
runGridScanner.drawCuts:  "DPhill=1.8, Mll=55"

runGridScanner.plotFormat: png

# the desired titles of the plots
# can be anything that is accepted by TH1*::SetTitle()
# variable titles can be referenced as 
#   $(VAR) in a 1D-case
runGridScanner.plotTitle: $(VAR)
#   $(VARX) and $(VARY) in a 2D-case
runGridScanner.plotTitle2D: $(VARY) vs. $(VARX)

# choose title of figure of merit for profile significance plots
# if not set the default is "Z_{exp}"
runGridScanner.profile.titleFigureOfMerit: Expected Significance

# choose index of FOM that should be plotted (default = 0)
# (see your above runGridScanner.figureOfMerits definitions)
# runGridScanner.indexFOMForPlotting: 0

# the fractions for which significance profiles should be made
# i.e. "Top x% of Cut Configurations"
runGridScanner.profile.sigTopFractions: 0.05

# minimum value of figure of merit for figure of merit profile plots
runGridScanner.profile.plotMinSignificance: 2.

# More style options for plotting (all given values are the defaults)
# runGridScanner.style.XaxisTitleSize: 0.04
# runGridScanner.style.YaxisTitleSize: 0.04
# runGridScanner.style.XaxisLabelSize: 0.04
# runGridScanner.style.YaxisLabelSize: 0.04
# runGridScanner.profile.showmax: True
# runGridScanner.profile.legend.fontSize: 0.04
# runGridScanner.profile.arrow.width: 2
# marker.size also controls arrow size (See TGraphPainter)
# runGridScanner.profile.marker.size: 2
# runGridScanner.profile.marker.style: 33

# If your legend of the significance profiles need to be shifted:
# runGridScanner.profile.legend.hmargin: 0.2
# runGridScanner.profile.legend.width: 0.3
# runGridScanner.profile.legend.height: 0.3
# runGridScanner.profile.legend.vmargin: 0.02
